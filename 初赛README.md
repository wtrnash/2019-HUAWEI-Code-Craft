# 2019华为软件精英挑战赛

##  赛题要求

 在模拟的道路图上为每一辆车规划行驶路线，系统会自动根据规划路线运行。在路线合法的前提下，最终所有车辆按照规划的路线到达目的地。

## 赛题理解

道路规划问题

## 3.14版本

根据车的最高速度和路的限速，求出该车在每条路上的所需时间，然后利用dijkstra算法求出最短（时间）路径。处理好了输入和输出接口。先跑通程序。再考虑后续根据全局信息进行道路规划的问题。

## 3.15

提交代码时要把所有地图类文件夹删掉，不然会上传代码失败。然后运行时程序失败。可能锁死了（处理到很晚原来是华为后台的问题，调试了半天）。看了一下map1，最长的道路长度为20。总共有10240辆车，下面是计划出发时间对应的车辆数，每分钟出发的车太多了，所以人为地来控制出发时间。

计划出发时间 数量

5                       1064
1                       1051
7                       1049
4                       1047
8                       1026
6                       1012
10                     1007
2                       1007
9                        995
3                         982

按出发时间排序，改成了每个单位时间发10辆车，两张地图总成绩2222。每秒20、15、13辆都死锁。12辆两张地图总成绩1887

## 3.16

启发式算法，如果让速度快的车先跑，那么速度快的车大概率能先跑完全程，这样道路上的车会比较少，而且堵车的情况也会缓解（堵车会根据前面的车速），所以将车按计划出发时候升序以及速度降序排序，这样每单位时间发15车还会死锁，但是每单位时间发13车就不死锁了，两张地图总成绩1820。

再对迪杰斯特拉时的路径权值进行调整，即计算最短路径时要考虑该路径的权重。每跑过一条路，该路径权重加10。这样单位时间发15辆车就不死锁了，两张地图总成绩1573。20辆车也不死锁，总成绩1235。 22辆车也不死锁，总成绩1190。23、24辆就死锁了。

## 3.17

将车辆的排序移到迪杰斯特拉之前，这样按顺序可以更好的匹配路径权值增加的情况，但反而两张地图总成绩变成了1203，发23辆即死锁。（后来发现是排序完没赋值回去）

## 3.18

考虑到之前版本的权值计算没有考虑实时性，即有可能前段时间这条路车子经过多，但后面一段时间该条路没有车了，但按之前的计算方法，该条路的权值还是会很高。所以进行了改进，先将车子的出发时间设置好，根据他的最短路径算出该路径上通过车子所在的时间，这样当计算权值时，拿当前的出发时间和这些时间段重复的次数来计算路径权值，并考虑了路的车道数。发20辆，总成绩1256。 22辆车总成绩1170。23辆车1106。24辆车1091。25辆车1053。26辆车死锁。 具体算法如下：

```Python
def get_time(self, road_id, v1, v2, length, start_time):
    """
    车通过该路的时间，根据路况对纯粹时间加上权值.
    :param v1: 汽车最高速度.
    :param road_id: 通过的道路id.
    :param v2: 道路的最高速度.
    :param length: 道路长度.
    :param start_time: 该车的出发时间
    :return: 处理后的通过时间.
    """
    car_time_list = self.cars_in_roads[road_id]
    weight = 0
    car_num = 0
    index = 0
    for time in car_time_list:
        if time[1] + 20 < start_time:   # 因为车子按时间顺序进来，所以为了效率，移除已经开走的车子时间组
            index += 1
        if time[0] - 20 <= start_time <= time[1] + 20:   # 该车的出发时间和在路段上车的时间大致相重合
            car_num += 1

    self.cars_in_roads[road_id] = car_time_list[index:]
    channel_number = self.roads[road_id].channel

    weight += (car_num // channel_number) * 10

    return self.get_pure_time(v1, v2, length) + weight
```

加上对同一时间同一地点发车的进行推迟，每秒25辆总成绩1375。 26辆是1345。 30辆1281。35辆1140。40辆是1064。45辆死锁。前90%发40辆，后10%发50辆死锁。前99%发40辆车，后1%发50辆车，总成绩1051。前97%发40辆，后3%发50辆，总成绩1045。前97%发42辆，后3%发50辆，总成绩1019。前97%发42辆，后3%发55辆死锁。前97%发42辆，后3%发53辆死锁。前97%发43辆，后3%发51辆死锁。前97%发42辆，后3%发51辆成绩1021。前96%发42辆，后4%发51辆死锁。

## 3.19

对刚开始发的前3%车，也每秒发50辆。然后对3.18版本进行了精细处理（之前是之间前97%除以42，后3%除以50），如下所示

```Python
if count / cars_num <= 0.03:        # 前3%的车
    car.plan_time += count // 50
elif count / cars_num >= 0.97:     # 最后3%的车
    car.plan_time += int((cars_num * 0.03) // 50 + cars_num * 0.94 // 42 + (count - cars_num * 0.97) // 55)
else:
    car.plan_time += int(cars_num * 0.03 // 50 + (count - cars_num * 0.03) // 42)
```

结果最后3%的车发50辆后成绩还没之前好，发52、55辆成绩都更差了。然后开头3%发52辆车时死锁。

将最后10辆车的时间都提前10，总成绩1013。将最后20辆提前20，总成绩还是1013。最后30辆提前30，死锁。30辆提前20，还是1013。30辆车提前25，还是1013。50辆车提前25,1017更慢了。

## 3.20

以速度为优先级排序，每秒20辆，前后3%每秒25辆，成绩1235。 每秒22辆，前后3%每秒25辆，成绩1145。每秒24辆，前后3%每秒25辆，成绩1074。    现在改成统一发25辆，成绩1065。

调整了一下程序。先按速度最高优先级降序，时间第二优先级升序排序，然后如果同一个出发点有三辆车以上，则将超出的车出发时间往后移。然后每秒发30辆，成绩1063。发33，35辆死锁。发31辆1054。 发31辆，最后3%发40辆，成绩991。 再提升参数都死锁。

## 3.24

尝试按往右、往左、往上、往下的方式来安排车出发，达到尽量避免死锁的目的。按之前的配置，去掉了同一地点的推迟发车设置，优先按速度排会死锁，所以优先按方向排，map1成绩520，map2死锁。 

## 3.25

优先按速度排序，然后是方向、时间。每秒发25辆，总成绩1076。发26辆还是死锁。试了很久，感觉同一个方向发车不行，这样逆向车道都没利用起来，速度反而慢了。

调整了下思路，同一个出发点三辆车以上如果方向一致才会往后移。每秒25辆成绩为1050。然后最后3%发30辆成绩为1048。而去除方向信息成绩为1087。2辆车以上则死锁了。每秒发车辆也按时间递减，因为一开始速度比较快，所以能跑的车多。

```Python
if plan_time_map[last_time] > 26 - int((count / cars_num) * 6):
    last_time += 1
```

按上面的公式成绩是1070。把26改成27，成绩是1043。改成28，是1012。改成29，死锁。

## 3.26

调试发车逻辑，发现速度快的时候容易死锁，因为速度快的车容易因为和前车距离不够而等待前车，但速度慢的车就能够往前行，所以速度快的车较容易死锁。我之前速度快的车发车多感觉有点问题。但是按前面车发的少，后面车发的多也死锁。

## 3.29

复现了之前的好的成绩。迪杰斯特拉换了套参数，初始是权值是长度除以车道最大速度，每有来车，权值加上1/车道数量。权值持续10分钟有效。同一个地点不超过3辆发车。按速度排序。 每秒发32辆，成绩是961。发34辆是933。35辆死锁。

## 3.30

初赛正式阶段Python代码直接超时，思想还是之前933权值的思想，面对新地图用Java复现后进行调参，前90%的车每个单位时间发34辆，后10%的车每个单位时间发40辆。最后成绩3879，以杭厦赛区22名进入复赛。